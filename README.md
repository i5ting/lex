# 学习lex



## 0.入门

### 编译

Lex 编程可以分为三步：

- 以 Lex 可以理解的格式指定模式相关的动作。
- 在这一文件上运行 Lex，生成扫描器的 C 代码。
- 编译和链接 C 代码，生成可执行的扫描器。


具体执行，编译分3步

- `lex a.lex`
- `cc -o parser lex.yy.c -ll` 
- `./parser`


注意
- 如果不加-ll链结选项，cc编译时会出现以下错误，后面会进一步说明。

### 代码分段

一个 Lex 程序分为三个段：

- 第一段是 C 和 Lex 的全局声明
- 第二段包括模式（C 代码）
- 第三段是补充的 C 函数。 例如, 第三段中一般都有 main() 函数。这些段以%%来分界


LEX源程序由三部分组成：说明部分；转换规则和辅助过程，用%%做间隔符。格式为： 

```
{ 说明部分 / 辅助定义 / definitions } -- 花括号括起来的部分都不是必须的.对转换规则和用户子程序也是如此. 
％％                  -- 必须的, 标志着识别规则的开始. 
{转换规则 / 识别规则 / rules }  
％％                     
{ 辅助过程 / 用户子程序 / user subroutines }
```

## 1.echo

和shell里的echo命令一样，实现回声功能

a.lex

```
%%
.|\n  ECHO;
%%
```


编译


```
npm run 1
```


## 1.1小写转大写


a.lex


```
%{
  #include "stdio.h"
%}
%%
[a-z]     printf("%c",yytext[0]+'A'-'a');
%%
```

## 2.识别加减乘除


a.lex

```
  %{
  #include "stdio.h"
  %}
  %%
  [\n]                  ;
  [0-9]+                printf("Int     : %s\n",yytext);
  [0-9]*\.[0-9]+        printf("Float   : %s\n",yytext);
  [a-zA-Z][a-zA-Z0-9]*  printf("Var     : %s\n",yytext);
  [\+\-\*\\\%]          printf("Op      : %s\n",yytext);
  .                     printf("Unknown : %c\n",yytext[0]);
  %%
```

说明

- 引入include，这样就可以使用c中的printf函数


执行

测试，指定文件输入

```
npm run 2.1
```

自己输入

```
npm run 2
```
## 3.嵌入C语言



## 4.标记声明类似 C 中的变量名。

每个标记都有一个相关的表达式。 （下表中给出了标记和表达式的例子。） 使用这个表中的例子，我们就可以编一个字数统计的程序了。 我们的第一个任务就是说明如何声明标记。

标记声明举例

- 数字(number)	([0-9])+	1个或多个数字
- 字符(chars)	[A-Za-z]	任意字符
- 空格(blank)	" "	一个空格
- 字(word)	(chars)+	1个或多个 chars
- 变量(variable)	(字符)+(数字)*(字符)*(数字)*


# 附录

## Lex 的常规表达式


- `A-Z, 0-9, a-z`	构成了部分模式的字符和数字。
- `.`	匹配任意字符，除了 \n。
- `-`	用来指定范围。例如：A-Z 指从 A 到 Z 之间的所有字符。
- `[ ]`	一个字符集合。匹配括号内的 任意 字符。如果第一个字符是 ^ 那么它表示否定模式。例如: [abC] 匹配 a, b, 和 C中的任何一个。
- `*`	匹配 0个或者多个上述的模式。
- `+`	匹配 1个或者多个上述模式。
- `?`	匹配 0个或1个上述模式。
- `$`	作为模式的最后一个字符匹配一行的结尾。
- `{ }`	指出一个模式可能出现的次数。 例如: A{1,3} 表示 A 可能出现1次或3次。
- `\`	用来转义元字符。同样用来覆盖字符在此表中定义的特殊意义，只取字符的本意。
- v^`	否定。
- `|`	表达式间的逻辑或。
- `"<一些符号>"`	字符的字面含义。元字符具有。
- `/`	向前匹配。如果在匹配的模版中的“/”后跟有后续表达式，只匹配模版中“/”前 面的部分。如：如果输入 A01，那么在模版 A0/1 中的 A0 是匹配的。
- `( )`	将一系列常规表达式分组。


常规表达式举例

- `joke[rs]`	匹配 jokes 或 joker。
- `A{1,2}shis+`	匹配 AAshis, Ashis, AAshi, Ashi。
- `(A[b-e])+`	匹配在 A 出现位置后跟随的从 b 到 e 的所有字符中的 0 个或 1个。
- abc可以匹配abc
- abc*可以匹配ab, abc, abcc, abccc, …
- abc+可以匹配abc, abcc, abccc, …
- a(bc)+可以匹配abc, abcbc, abcbcbc, …
- a(bc)?可以匹配a, abc
- [abc]可以匹配a, b, c
- [a-z]可以匹配任何a到z之间的字符
- [a\-z]可以匹配a, -, z
- [-az]可以匹配-, a, z
- [A-Za-z0-9]+可以匹配一个或多个字符串
- [ \t\n]+可以匹配空格, tab和换行
- [^ab]可以匹配除去a和b之外的任何字符
- [a^b]可以匹配a, ^, b
- [a|b]可以匹配a, |, b
- a|b 可以匹配a 或者 b

## Lex 变量

- yyin	FILE* 类型。 它指向 lexer 正在解析的当前文件。
- yyout	FILE* 类型。 它指向记录 lexer 输出的位置。 缺省情况下，yyin 和 yyout 都指向标准输入和输出。
- yytext	匹配模式的文本存储在这一变量中（char*）。
- yyleng	给出匹配模式的长度。
- yylineno	提供当前的行数信息。 （lexer不一定支持。）

## Lex 函数

- yylex()	这一函数开始分析。 它由 Lex 自动生成。
- yywrap()	这一函数在文件（或输入）的末尾调用。 如果函数的返回值是1，就停止解析。 因此它可以用来解析多个文件。 代码可以写在第三段，这就能够解析多个文件。 方法是使用 yyin 文件指针（见上表）指向不同的文件，直到所有的文件都被解析。 最后，yywrap() 可以返回 1 来表示解析的结束。
- yyless(int n)	这一函数可以用来送回除了前�n? 个字符外的所有读出标记。
- yymore()	这一函数告诉 Lexer 将下一个标记附加到当前标记后。
